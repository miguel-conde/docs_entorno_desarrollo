---
title: "Gu√≠a de Configuraci√≥n de Entorno de Data Science con Python y R en Windows (WSL2 + VS Code)"
format: 
    html:
        toc: true
        toc-location: right
        toc-floating: true
        self-contained: true
number-sections: true
---

## Requisitos Previos

Antes de comenzar, aseg√∫rate de contar con los siguientes requisitos m√≠nimos y recomendados:

* **Sistema Operativo:** Windows 10 (versi√≥n 2004 o superior) o Windows 11, con soporte para WSL2. Es imprescindible un sistema de 64 bits con la virtualizaci√≥n habilitada en la BIOS.
* **Hardware:** Se recomienda un procesador multin√∫cleo moderno y al menos 8 GB de RAM (16 GB o m√°s ideal para cargas de trabajo intensivas en datos y entrenamiento de modelos). Tambi√©n es aconsejable disponer de una unidad SSD con espacio libre amplio (decenas de GB) para instalar paquetes, datos y contenedores Docker.
* **Software:** Visual Studio Code (√∫ltima versi√≥n) instalado en Windows. Contar√°s con la extensi√≥n *Remote - WSL* para VS Code (se detalla su instalaci√≥n m√°s adelante). Asimismo, necesitar√°s una distribuci√≥n Linux (ej. Ubuntu) instalada en WSL2 y actualizada.
* **Versiones de Python y R:** Python 3 (se recomienda la versi√≥n m√°s reciente, p. ej. 3.10 o superior) y R (versi√≥n 4.x) para asegurar compatibilidad con las herramientas modernas.
* **Conexi√≥n a Internet:** necesaria para descargar paquetes, contenedores Docker y otras dependencias durante la instalaci√≥n y configuraci√≥n inicial.

Con los requisitos anteriores cubiertos, podr√°s proceder a instalar WSL2 y a configurar el entorno de desarrollo.

## Instalaci√≥n de WSL¬†2, Ubuntu y Configuraci√≥n Inicial

Para instalar el Subsistema de Windows para Linux 2 (WSL¬†2) con Ubuntu, sigue estos pasos:

1. **Habilitar WSL¬†2 en Windows:** Abre una ventana de PowerShell **como administrador** y ejecuta el comando de instalaci√≥n r√°pida de WSL:

   ```powershell
   wsl --install
   ```

   Este comando habilita las caracter√≠sticas necesarias (Plataforma de M√°quina Virtual y WSL) e instala por defecto la distribuci√≥n Ubuntu. Al finalizar, reinicia el equipo si as√≠ lo indica la consola. *(Nota: En Windows 10 antiguos puede ser necesario habilitar manualmente las caracter√≠sticas mediante `dism.exe` como se explica en la documentaci√≥n, pero en versiones recientes `wsl --install` realiza todos los pasos autom√°ticamente.)*

2. **Elegir distribuci√≥n Linux (opcional):** Por defecto se instala Ubuntu. Si deseas otra distribuci√≥n (Debian, Kali, etc.), puedes listar las disponibles con `wsl --list --online` y luego instalar una espec√≠fica con `wsl --install -d <NombreDistro>`.

3. **Establecer WSL¬†2 como versi√≥n predeterminada:** En la mayor√≠a de sistemas actuales, WSL¬†2 ser√° el valor por defecto. Si fuera necesario (por ejemplo, en Windows 10 actualizado desde versiones antiguas), fuerza WSL¬†2 como versi√≥n predeterminada con:

   ```powershell
   wsl --set-default-version 2
   ```

   Si al ejecutar este comando aparece un mensaje indicando que falta el kernel de WSL¬†2, descarga e instala la actualizaci√≥n del kernel desde el enlace oficial (aka.ms/wsl2kernel) antes de continuar.

4. **Iniciar Ubuntu y crear usuario:** Tras reiniciar, inicia la aplicaci√≥n "Ubuntu" reci√©n instalada (desde el men√∫ Inicio o ejecutando `wsl` en PowerShell). En el primer inicio, se abrir√° una consola de Ubuntu solicitando que definas un nombre de usuario *Linux* (distinto del de Windows, puede ser tu nombre) y una contrase√±a. Introduce credenciales para crear tu usuario normal en la distro Linux. **Importante:** recuerda esa contrase√±a, ya que la necesitar√°s para usar `sudo` (privilegios administrativos en Linux).

5. **Actualizar el sistema Ubuntu:** Una vez en la consola de Ubuntu (WSL), es recomendable actualizar los paquetes a la √∫ltima versi√≥n. Ejecuta:

   ```bash
   sudo apt update && sudo apt upgrade -y
   ```

   Esto refresca los repositorios e instala actualizaciones disponibles.

6. **Instalar herramientas de desarrollo esenciales:** Para trabajar con Python y R, instala paquetes b√°sicos de compilaci√≥n y utilidades. Por ejemplo:

   ```bash
   sudo apt install -y build-essential git curl wget libssl-dev libffi-dev
   ```

   * `build-essential` proporciona compiladores (gcc/g++), necesarios para construir paquetes Python (v√≠a pip/poetry) o R desde fuente.
   * `git` permitir√° el control de versiones.
   * Otras librer√≠as como `libssl-dev`, `libffi-dev` u otras (`zlib1g-dev`, `libxml2-dev`, etc.) pueden ser requeridas al compilar ciertas dependencias de Python o R. Tenerlas instaladas previene errores de compilaci√≥n m√°s adelante.

Con WSL2 y Ubuntu instalados y actualizados, ya dispones de un entorno Linux base dentro de Windows. En los siguientes pasos configuraremos Visual Studio Code y las herramientas espec√≠ficas de Python y R en este entorno.

## Configuraci√≥n de Visual Studio Code con Remote - WSL

Con WSL2 operativo, puedes usar Visual Studio Code para desarrollar directamente en el entorno Linux. Los pasos para configurar VS Code con WSL son:

1. **Instalar VS Code en Windows:** Descarga e instala Visual Studio Code (versi√≥n Windows x64) desde la p√°gina oficial. Durante la instalaci√≥n, activa la opci√≥n "Add to PATH" para poder lanzar VS Code desde la l√≠nea de comandos con `code`.

2. **Instalar la extensi√≥n Remote - WSL:** En VS Code, abre la pesta√±a de extensiones y busca **Remote Development** (un paquete de extensiones oficial de Microsoft). Instala el paquete *Remote Development*, el cual incluye la extensi√≥n *Remote - WSL* (adem√°s de Remote SSH y Remote Containers). Esta extensi√≥n permite que VS Code se ejecute dentro de WSL2, de modo que puedas abrir carpetas y archivos que residen en Linux directamente desde VS Code en Windows.

3. **Abrir una sesi√≥n VS Code en WSL:** Existen dos maneras comunes:

   * **Desde la terminal WSL:** Navega hasta la carpeta de tu proyecto (ejemplo: `cd ~/mi-proyecto`) y ejecuta `code .`. Este comando abrir√° VS Code conectado a tu entorno Ubuntu en WSL, abriendo la carpeta actual. La primera vez, VS Code instalar√° su servidor interno en WSL autom√°ticamente.
   * **Desde VS Code (Windows):** Inicia VS Code en Windows sin abrir carpeta, presiona `Ctrl+Shift+P` y elige la opci√≥n **"WSL: Connect to WSL"** o **"WSL: Reopen Folder in WSL"**. Tambi√©n puedes seleccionar la distribuci√≥n (si tuvieras m√°s de una) con **"WSL: New WSL Window using Distro..."**. Esto abrir√° una nueva ventana de VS Code ya conectada al entorno Ubuntu WSL, lista para abrir proyectos all√≠.

4. **Administraci√≥n de extensiones en WSL:** Ten en cuenta que al usar VS Code con WSL, existe una arquitectura cliente-servidor: la interfaz de VS Code corre en Windows, pero tus herramientas, extensiones de desarrollo, terminal y archivos residen en Linux. Por ello, ciertas extensiones deben instalarse dentro de WSL. Por ejemplo, la extensi√≥n de Python, R o Docker deben aparecer instaladas "en WSL" para funcionar correctamente en ese entorno. VS Code normalmente te avisar√° (con un √≠cono ‚ö†Ô∏è) si una extensi√≥n que tienes en Windows requiere instalaci√≥n en WSL; puedes hacer clic en "Install in WSL" en la vista de Extensiones. Aseg√∫rate de instalar en WSL todas las extensiones relevantes:

   * **Python** (Microsoft) ‚Äì para soporte de Python (linting, debugging, Jupyter notebooks, etc).
   * **R** (si trabajar√°s con R, extensi√≥n *R* de Ikuyadeu) ‚Äì para soporte de lenguaje R.
   * **Docker** ‚Äì para integraci√≥n con Docker desde VS Code.
   * **Quarto** (Posit) ‚Äì √∫til si vas a trabajar con documentos .qmd o R Markdown (lo veremos en secci√≥n de Quarto).

   Igualmente, puedes instalar temas, iconos u otras extensiones de interfaz solo en Windows (no es necesario duplicarlas en WSL, ya que no interact√∫an con el entorno remoto).

Con esta configuraci√≥n, Visual Studio Code act√∫a como tu IDE principal, editando archivos dentro de WSL2 y aprovechando funcionalidades como IntelliSense, depuraci√≥n y control de versiones de manera transparente entre Windows y Linux.

## Entorno Python: Instalaci√≥n y Configuraci√≥n de Herramientas Esenciales

En el entorno Ubuntu WSL configurado, instalaremos ahora las herramientas clave para trabajar con Python de forma eficiente en proyectos de ciencia de datos y ML. Estas incluyen gestores de versiones y entornos, instaladores de paquetes, formateadores de c√≥digo, linters y m√°s.

### pyenv: Gestor de Versiones de Python

**pyenv** es una utilidad que permite instalar y alternar f√°cilmente entre m√∫ltiples versiones de Python en un mismo sistema. Con pyenv puedes tener, por ejemplo, Python 3.8, 3.10 y 3.11 coexistiendo, y elegir cu√°l usar globalmente o por proyecto. Esto es invaluable para probar compatibilidad o usar caracter√≠sticas espec√≠ficas de ciertas versiones.

**Instalaci√≥n:** Para instalar pyenv en Ubuntu WSL, puedes usar el instalador autom√°tico:

```bash
curl https://pyenv.run | bash
```

Este script descargar√° pyenv en `~/.pyenv` y configurar√° los scripts necesarios. Tras ejecutarlo, a√±ade las siguientes l√≠neas al final de tu fichero `~/.bashrc` (si el instalador no lo hizo autom√°ticamente):

```bash
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"
```

Luego recarga la configuraci√≥n (`source ~/.bashrc`) o abre una nueva terminal. Para verificar, ejecuta `pyenv --version`, que deber√≠a mostrar la versi√≥n de pyenv instalada.

**Uso b√°sico:**

* Instala una versi√≥n de Python con `pyenv install`. Por ejemplo, para instalar la √∫ltima versi√≥n de la serie 3.11: `pyenv install 3.11`. (Puedes listar versiones disponibles con `pyenv install -l`).
* Establece una versi√≥n global por defecto: `pyenv global 3.11.4` (ejemplo de versi√≥n espec√≠fica). Esto hace que `python` apunte a esa versi√≥n globalmente.
* Alternativamente, usa `pyenv local <versi√≥n>` dentro de un directorio de proyecto para fijar la versi√≥n de Python solo en ese proyecto (crea un fichero `.python-version` en la carpeta).
* Tras instalar nuevas versiones, puedes usar `pyenv versions` para ver las instaladas y `python --version` para verificar cu√°l est√° en uso.

Con pyenv, el Python del sistema queda aislado: siempre puedes volver a √©l con `pyenv global system` si lo necesitas. pyenv no gestiona entornos virtuales por s√≠ mismo, pero se integra bien con herramientas como `virtualenv` o managers de proyectos como Poetry.

### pipx: Instalaci√≥n Aislada de Aplicaciones Python

**pipx** es una herramienta para instalar aplicaciones de l√≠nea de comando de Python de forma **aislada** del entorno principal. Es decir, para utilidades como `black`, `flake8`, `httpie`, `you-get`, etc., pipx crea entornos virtuales separados y los instala all√≠, haciendo disponibles los comandos en tu PATH de usuario. Esto evita conflictos de dependencias entre herramientas y mantiene limpio tu entorno base (no m√°s `sudo pip install` global).

**Instalaci√≥n:** En Ubuntu 22.04+ puedes instalar pipx con apt:

```bash
sudo apt install -y pipx
pipx ensurepath
```

Aseg√∫rate de que `~/.local/bin` est√© en tu PATH (pipx lo a√±ade con `ensurepath` para el usuario actual). Alternativamente, si pipx no est√° en los repos, puedes instalarlo con `python3 -m pip install --user pipx` y luego `pipx ensurepath`.

**Uso b√°sico:** Supongamos que quieres instalar la herramienta `httpie` (un cliente HTTP de consola):

```bash
pipx install httpie
```

Esto descargar√° el paquete desde PyPI, crear√° un virtualenv aislado en `~/.local/pipx/venvs/httpie` y expondr√° el comando `http` en tu PATH. Puedes luego ejecutar `http https://api.github.com` por ejemplo, sin preocuparte de que interfiera con otras librer√≠as Python.

Con pipx instalaremos varias de las herramientas a continuaci√≥n para mantenerlas separadas del entorno principal.

### Poetry y uv: Gesti√≥n de Entornos Virtuales y Dependencias de Proyecto

Para gestionar las dependencias de cada proyecto Python y aislar su entorno, existen herramientas de alto nivel como **Poetry** y **uv**. Ambas utilizan el est√°ndar `pyproject.toml` para definir dependencias y permiten reproducir entornos f√°cilmente a partir de archivos de bloqueo (lockfiles).

* **Poetry:** Es un gestor de dependencias y empaquetado para Python, muy popular en los √∫ltimos a√±os. Con Poetry puedes definir las librer√≠as requeridas en un proyecto (y sus versiones) en un fichero `pyproject.toml` y Poetry se encarga de crear un entorno virtual aislado y resolver las versiones compatibles, generando un `poetry.lock` para fijar las versiones exactas instaladas. Poetry tambi√©n facilita la publicaci√≥n de paquetes propios. La forma recomendada de instalar Poetry es a trav√©s de pipx (evitando su script oficial), por ejemplo:

  ```bash
  pipx install poetry
  ```

  De este modo Poetry quedar√° instalado en un entorno aislado (as√≠ no se rompe si actualizas la versi√≥n global de Python). Tras instalarlo, puedes inicializar un nuevo proyecto con `poetry init` interactivo, a√±adir dependencias con `poetry add <paquete>` (usar `-D` o `--group dev` para dependencias de desarrollo), instalar todas las dependencias con `poetry install` y ejecutar comandos dentro del entorno con `poetry run <comando>` o abrir un shell con `poetry shell`. Poetry crear√° autom√°ticamente un entorno virtual (normalmente ubicado en `~/.cache/pypoetry/virtualenvs/`).

* **uv:** Es una herramienta m√°s reciente, escrita en Rust y publicada por la empresa Astral (creadores del formateador `ruff`). uv se presenta como un "todo en uno" r√°pido para gestionar proyectos Python: su objetivo es reemplazar a pip, pipx, virtualenv, pip-tools y Poetry con una sola interfaz. De hecho, uv puede instalar Python (similar a pyenv), administrar entornos, instalar aplicaciones CLI (reemplazando pipx) y gestionar dependencias de proyectos con un lockfile √∫nico para todos los entornos. Es notablemente r√°pido (hasta 10‚Äì100 veces m√°s que pip en instalaci√≥n de paquetes, gracias a su implementaci√≥n en Rust). Para instalar uv, tambi√©n podemos usar pipx:

  ```bash
  pipx install uv
  ```

  (uv est√° disponible en PyPI, facilitando su instalaci√≥n). Una vez instalado, el flujo de trabajo con uv es similar:

  * Iniciar un nuevo proyecto: `uv init` (crea pyproject.toml interactivo, similar a poetry init).
  * Agregar dependencias: `uv add <paquete>` (usa `--dev` para dependencias de desarrollo).
  * Instalar (sync) dependencias: `uv install` o simplemente usar `uv run` que autom√°ticamente asegura que el entorno est√© sincronizado.
  * Ejecutar comandos: `uv run <comando>` (ejecuta dentro del entorno del proyecto).

  uv administra autom√°ticamente un entorno virtual por proyecto en el directorio `.uv` (dentro del proyecto, por defecto). Ofrece ventajas de velocidad y un enfoque unificado. Sin embargo, al ser relativamente nuevo, tiene algunas diferencias: por ejemplo, no soporta m√∫ltiples *groups* de dependencias separadas para dev/prod/test como s√≠ lo hace Poetry ‚Äî en uv todas las dependencias se instalan juntas (las marcadas como dev solo se excluyen al publicar un paquete). A√∫n as√≠, uv est√° ganando adopci√≥n r√°pidamente por su eficiencia.

**¬øPoetry o uv?** Ambas herramientas cumplen prop√≥sitos similares. Poetry es madura y ampliamente usada; uv es muy veloz y promete simplificar la gesti√≥n sustituyendo varias utilidades a la vez. Puedes elegir una u otra seg√∫n tus preferencias. Por ejemplo, si ya tienes experiencia con Poetry, sigue con Poetry; si valoras el rendimiento y un workflow m√°s sencillo, puedes probar uv. En cualquier caso, usar uno de estos gestores es altamente recomendable para mantener proyectos aislados y con dependencias reproducibles.

### Herramientas de Formateo, Linter y Calidad de C√≥digo

Para mantener un c√≥digo Python limpio, consistente y libre de errores comunes, se utilizan las siguientes herramientas en el flujo de trabajo:

* **Black:** formateador autom√°tico de c√≥digo. Configur√°ndolo, Black reescribe tu c√≥digo a un estilo est√°ndar (PEP 8) cada vez que lo ejecutas, evitando discusiones de estilo en el equipo. Su filosof√≠a es tener "una √∫nica manera de formatear" ‚Äî al aplicarlo regularmente, el dif de cambios se reduce solo a cuestiones l√≥gicas, nunca de formato.
* **isort:** organizador autom√°tico de imports. isort ordena las importaciones alfab√©ticamente y separa los grupos (built-in, terceros, locales) de forma consistente.
* **Flake8:** es una herramienta de linting que combina PyFlakes, pycodestyle y mccabe, detectando errores de sintaxis, malas pr√°cticas y violaciones de estilo PEP8 que un formateador no corrige (por ejemplo, variables definidas pero no usadas, etc).
* **mypy:** es un analizador de tipos est√°tico para Python. Si anotas tu c√≥digo con *type hints*, mypy comprueba coherencia de tipos sin ejecutar el programa, capturando una clase de errores antes de tiempo (ej: pasar un `str` donde se espera un `int`, etc).
* **pre-commit:** es una herramienta para gestionar *hooks* de Git pre-compilaci√≥n. Permite definir una serie de acciones que se ejecuten autom√°ticamente **antes** de cada commit, por ejemplo, ejecutar Black, isort y flake8 para asegurar que el c√≥digo que vas a commitear est√° formateado y libre de errores simples. De este modo, mantienes la calidad de c√≥digo de forma consistente en cada commit.

**Instalaci√≥n:** Todas estas herramientas se pueden instalar de forma global con pipx, o bien agregarlas como dependencias de desarrollo en Poetry/uv para cada proyecto. Una aproximaci√≥n com√∫n es instalarlas con pipx para poder usarlas en cualquier directorio/proyecto. Por ejemplo:

```bash
pipx install black
pipx install isort
pipx install flake8
pipx install mypy
pipx install pre-commit
```

Ver√°s que cada comando quedar√° disponible globalmente (`black --version`, `flake8 --version`, etc., deben responder una vez instalados).

**Configuraci√≥n y uso:**

* Puedes ejecutar Black e isort manualmente sobre tus archivos (`black .` formatear√° todo el proyecto, e `isort .` ordenar√° imports).
* Flake8 y mypy se pueden correr para analizar el c√≥digo (`flake8 .` / `mypy .`) y ver reportes de problemas.
* pre-commit se configura a√±adiendo un archivo `.pre-commit-config.yaml` en el repositorio, listando los hooks (por ejemplo, usar los hooks oficiales de black, isort, flake8, mypy, incluso hooks para verificar que los notebooks est√°n limpios de outputs, etc.). Luego ejecutas `pre-commit install` una vez en el repo para habilitar los hooks de git. A partir de entonces, cada `git commit` disparar√° autom√°ticamente las herramientas: t√≠picamente, formatear√° el c√≥digo y evitar√° el commit si hay errores de lint o tipos, hasta que se corrijan.
* Todas estas herramientas son altamente configurables mediante ficheros de configuraci√≥n: `pyproject.toml` o espec√≠ficos como `black.toml`, `flake8.ini`, `mypy.ini` etc. Por ejemplo, puedes configurar el line-length que usa Black, reglas a ignorar en flake8, estilos de import en isort, directorios a excluir, etc. Adaptar estas configuraciones a las gu√≠as de tu proyecto es recomendable.

Integrar estas utilidades en tu flujo de trabajo mejora enormemente la calidad y consistencia del c√≥digo. Un flujo t√≠pico ser√≠a: al guardar, Black e isort pueden formatear autom√°ticamente (VS Code puede configurarse para ejecutar formateador al guardar); antes de hacer commit, pre-commit ejecuta nuevamente Black/isort (asegurando que nada qued√≥ sin formatear), flake8 y mypy revisan el c√≥digo, y si algo falla, el commit se aborta para que lo corrijas. As√≠, cualquier error evidente se corrige antes de entrar al repositorio.

## Entorno R: Instalaci√≥n y Configuraci√≥n de Herramientas Esenciales

Ahora configuraremos R dentro de WSL para proyectos de an√°lisis de datos y estad√≠stica, integr√°ndolo con VS Code.

### Instalaci√≥n de R en Ubuntu (WSL)

Para instalar R en Ubuntu (WSL), la forma m√°s sencilla es usar los repositorios apt:

```bash
sudo apt update
sudo apt install -y r-base r-base-dev
```

Esto instalar√° la √∫ltima versi√≥n de R disponible en los repositorios de tu versi√≥n de Ubuntu, junto con las herramientas de desarrollo (`r-base-dev`) necesarias para compilar paquetes R desde c√≥digo fuente. *Nota:* Si deseas la versi√≥n m√°s reciente de R y tu distribuci√≥n no la incluye, puedes a√±adir el repositorio oficial de CRAN. Por ejemplo, para Ubuntu 22.04 *Jammy*, a√±adir una l√≠nea como `deb https://cloud.r-project.org/bin/linux/ubuntu jammy-cran40/` en `/etc/apt/sources.list` (y agregar la clave GPG de CRAN) te permitir√° instalar R 4.2+ desde CRAN. Tras agregar, ejecutar de nuevo `apt update` e instalar `r-base`. (Consulta la documentaci√≥n de CRAN para instrucciones detalladas).

Una vez instalado, puedes lanzar R escribiendo `R` en la terminal de Ubuntu. Ver√°s el interprete de R funcionando en WSL.

### languageserver: Autocompletado y Soporte de Lenguaje R en VS Code

Para que VS Code brinde funcionalidades de IDE (autocompletado, help, salto a definiciones, etc.) para R, se utiliza el **R Language Server**. Este servidor LSP es proporcionado por el paquete `languageserver` de R. Debes instalarlo dentro de R (en WSL):

1. Abre una sesi√≥n de R (ejecuta `R` en la terminal).
2. En la consola de R, instala el paquete ejecutando:

```r
install.packages("languageserver")
```

Este paquete implementa el Language Server Protocol para R. La extensi√≥n de R en VS Code lo utilizar√° autom√°ticamente para ofrecer autocompletado inteligente, informaci√≥n de funciones, diagn√≥stico de errores de sintaxis, etc.

A continuaci√≥n, en VS Code, aseg√∫rate de tener instalada la **extensi√≥n R** (de Ikuyadeu). Si la instalaste previamente en Windows, verifica en la pesta√±a de Extensiones (como mencionamos en la secci√≥n de VS Code) que tambi√©n est√© instalada en el entorno WSL. Esta extensi√≥n detectar√° el `languageserver` y lo lanzar√° en segundo plano al abrir archivos `.R` o trabajar en un script R, habilitando funcionalidades como completion y hints en el editor.

### Plotting: Visor de Gr√°ficas con httpgd

En entornos sin interfaz gr√°fica (como WSL sin un servidor X11), la visualizaci√≥n de gr√°ficas de R puede lograrse mediante dispositivos gr√°ficos especiales. La extensi√≥n de R para VS Code recomienda el paquete **httpgd**, que act√∫a como un servidor de gr√°ficos v√≠a web sockets. Inst√°lalo igualmente desde R:

```r
install.packages("httpgd")
```

`httpgd` provee un dispositivo gr√°fico que sirve las im√°genes (SVG) v√≠a HTTP/WebSocket, permitiendo a VS Code mostrar las gr√°ficas interactivamente. Tras instalarlo, abre VS Code, y en la configuraci√≥n de la extensi√≥n R busca la opci√≥n de **Gr√°ficos**. Aseg√∫rate que est√© configurado para usar **httpgd**. Cuando generes una gr√°fica en R (por ejemplo con `plot()` o usando ggplot2), VS Code abrir√° autom√°ticamente un panel con la visualizaci√≥n interactiva de la gr√°fica.

### Consola mejorada: radian (opcional)

Por defecto, la extensi√≥n R lanza el int√©rprete est√°ndar de R en la terminal de VS Code. Opcionalmente, puedes instalar **radian**, una consola alternativa de R escrita en Python, que provee mejoras como autocompletado avanzado, sintaxis resaltada en la consola y mejor manejo de la historia. Para instalar radian, primero instala pip (si no lo tienes) y luego ejecuta:

```bash
pipx install radian   # o pip install --user radian
```

Luego, en la configuraci√≥n de VS Code, especifica la ruta del ejecutable radian en la opci√≥n `r.rterm.windows` o `r.rterm.linux` seg√∫n corresponda, y habilita `r.bracketedPaste`. Con esto, al iniciar una sesi√≥n R en VS Code, utilizar√° radian proporcionando una experiencia m√°s rica en la consola (por ejemplo, par√©ntesis coloreados, autocompletar mientras escribes, etc.).

### Dependencias de sistema para paquetes de R

Muchos paquetes de R escritos en C/C++ o que envuelven bibliotecas externas requieren tener instaladas ciertas dependencias de sistema. Ya instalamos `r-base-dev` que incluye las herramientas de compilaci√≥n b√°sicas. Sin embargo, podr√≠as necesitar otros paquetes de desarrollo:

* Por ejemplo, para bases de datos o APIs web: `libcurl4-openssl-dev` (para curl), `libxml2-dev` (para XML), `libssl-dev` (para SSL), etc.
* Para ciertos paquetes de gr√°ficos o ciencia de datos: `libpng-dev`, `libjpeg-dev`, `libatlas-base-dev`, `gfortran`, etc.

La necesidad exacta depender√° del paquete R que instales. Si al usar `install.packages()` en R ves errores de compilaci√≥n indicando falta de alguna librer√≠a, busca el nombre de la librer√≠a y probablemente inst√°lala con apt ese `-dev`. Por ejemplo, si falla por *curl*, instala `libcurl4-openssl-dev` y vuelve a intentarlo.

En resumen, con R instalado y configurado con **languageserver** para VS Code y **httpgd** para gr√°ficos, tendr√°s una experiencia de desarrollo c√≥moda: VS Code te brindar√° iluminaci√≥n de sintaxis, autocompletado y ayuda en tus scripts R, y podr√°s ejecutar c√≥digo R directamente en la terminal integrada o en notebooks (R Markdown/Quarto) con visualizaci√≥n de resultados y gr√°ficas dentro del editor.

## Integraci√≥n de Quarto

**Quarto** es una plataforma unificada para documentos reproducibles, que permite combinar Markdown con c√≥digo ejecutable de R, Python, Julia y otros lenguajes en un mismo documento. Es la evoluci√≥n de R Markdown, desarrollada por Posit (antes RStudio), orientada a generar reportes, libros, sitios web o presentaciones de forma reproducible. Integrar Quarto en nuestro entorno nos permitir√° crear informes con texto, c√≥digo y gr√°ficas de forma integrada, aprovechando tanto R como Python en un solo documento `.qmd`.

### Instalaci√≥n de la CLI de Quarto en WSL

Para poder renderizar documentos Quarto, necesitamos instalar la herramienta de l√≠nea de comando de Quarto en Ubuntu WSL. Posit distribuye instaladores para Linux en formato .deb:

1. Ve a la p√°gina oficial de Quarto (quarto.org) y descarga el paquete `.deb` para Ubuntu (por ejemplo, para x86\_64). Tambi√©n puedes copiar el enlace de descarga.
2. En la terminal de Ubuntu, usa `wget` para descargar el .deb. Por ejemplo:

   ```bash
   wget https://github.com/quarto-dev/quarto-cli/releases/download/v1.8.9/quarto-1.8.9-linux-amd64.deb -O quarto.deb
   ```

   *(Nota: La versi√≥n y URL exacta pueden cambiar, verifica la √∫ltima versi√≥n estable.)*
3. Instala el paquete con dpkg:

   ```bash
   sudo dpkg -i quarto.deb
   ```

   Si ves errores de dependencias, ejecuta `sudo apt-get install -f` para instalarlas autom√°ticamente.
4. Verifica la instalaci√≥n con: `quarto --version`. Deber√≠as obtener el n√∫mero de versi√≥n de Quarto instalado.

### Uso de Quarto con VS Code

Ya hab√≠amos instalado la extensi√≥n **Quarto** en VS Code (si no, inst√°lala desde el Marketplace). Esta extensi√≥n proporciona integraci√≥n completa: comandos para renderizar documentos, atajos de teclado, realce de sintaxis, autocompletado de opciones YAML y de c√≥digo embebido (R/Python), vista previa en vivo de los documentos, etc.

Con Quarto instalado, puedes crear un nuevo documento Quarto (archivo `.qmd`). Por ejemplo, crea `analysis.qmd` con contenido R y Python mezclado en diferentes celdas. En VS Code, puedes renderizar el documento de varias formas:

* Abre el comando **"Quarto: Render"** o **"Quarto: Preview"** desde la paleta de comandos (Ctrl+Shift+P) o usa el atajo predeterminado (Ctrl+Shift+K abre la previsualizaci√≥n). La extensi√≥n ejecutar√° `quarto preview`, que renderiza el documento y abre una vista previa interactiva en VS Code, alineada junto al editor. Cada vez que guardes el documento, Quarto recargar√° la vista previa con los √∫ltimos resultados, incluyendo las salidas y gr√°ficas generadas por el c√≥digo.
* Puedes cambiar el formato de salida (HTML por defecto) a PDF, Word, etc., ajustando el YAML del encabezado del documento o usando el comando **"Quarto: Preview Format"** que permite elegir el formato a previsualizar.

Quarto se integra con los kernels de Jupyter y con R directamente, por lo que al renderizar ejecutar√° el c√≥digo Python con Python (o Jupyter) y el c√≥digo R con R, incrustando los resultados en el documento final. Puedes configurar qu√© kernel o int√©rprete usar para cada lenguaje en el YAML del documento (por defecto usar√° el R instalado en WSL para chunks `{r}` y el Python actual para chunks `{python}`).

Al utilizar Quarto en VS Code obtienes una poderosa combinaci√≥n:

* Puedes escribir informes mezclando texto, LaTeX, Markdown y c√≥digo de m√∫ltiples lenguajes.
* Obtienes **vista previa en vivo** dentro de VS Code de los resultados formateados (incluso con interactividad b√°sica en gr√°ficos HTML/JavaScript).
* Mantienes todo en un flujo reproducible: Quarto manejar√° la ejecuci√≥n del c√≥digo en orden y la inclusi√≥n de resultados, facilitando la colaboraci√≥n y la verificaci√≥n de que los resultados corresponden al c√≥digo fuente.

Por ejemplo, un cient√≠fico de datos puede crear un documento `analisis.qmd` donde carga datos con Python, entrena un modelo de machine learning, y luego en otra secci√≥n usar R para generar visualizaciones avanzadas, todo en el mismo documento. Con Quarto, al renderizar, ambos lenguajes producen una salida unificada en HTML/PDF.

Finalmente, destacar que Quarto tambi√©n permite generar presentaciones (reveal.js, Beamer), blogs o libros completos, lo que lo hace una herramienta muy vers√°til en el entorno de data science.

*(Si deseas profundizar, consulta la [documentaci√≥n oficial de Quarto](https://quarto.org/docs/) que incluye tutoriales desde "Hello, Quarto" hasta temas avanzados.)*

## Integraci√≥n de Docker con WSL 2 y Manejo de Permisos

Docker se ha convertido en una herramienta fundamental para reproducir entornos y desplegar aplicaciones. Gracias a WSL¬†2, es posible utilizar Docker de forma eficiente en Windows sin necesidad de m√°quinas virtuales pesadas, aprovechando el kernel Linux integrado. Hay dos formas principales de configurar Docker con WSL:

**Opci√≥n 1: Docker Desktop (recomendada).** Docker Desktop para Windows utiliza WSL¬†2 como backend, proporcionando una integraci√≥n fluida. Pasos resumen:

* Instala Docker Desktop en Windows (disponible en la web de Docker). Aseg√∫rate de cumplir los requisitos m√≠nimos (Windows 10 21H2+ o Windows 11) y tener WSL¬†2 habilitado.
* Inicia Docker Desktop y ve a *Settings > General*: verifica que "Use WSL 2 based engine" est√© activado. En *Settings > Resources > WSL Integration*: habilita la integraci√≥n con tu distribuci√≥n Ubuntu WSL.
* Docker Desktop iniciar√° el demonio de Docker dentro de WSL2 autom√°ticamente. En tu terminal de Ubuntu WSL, prueba el comando:

  ```bash
  docker run hello-world
  ```

  Esto descargar√° y ejecutar√° el contenedor de prueba "hello-world". Si todo est√° correctamente configurado, ver√°s un mensaje de √©xito desde el contenedor.

Es posible que al ejecutar Docker en WSL por primera vez obtengas un error de permiso denegado al acceder al socket de Docker. Para solucionarlo, a√±ade tu usuario de Linux al grupo `docker` dentro de WSL:

```bash
sudo usermod -aG docker $USER
```

Luego cierra y vuelve a abrir la sesi√≥n (o ejecuta `newgrp docker`). Esto permite usar Docker sin `sudo`. Docker Desktop configura autom√°ticamente el socket con este grupo. (En algunos casos, tambi√©n es necesario agregar tu usuario de Windows al grupo local "docker-users", aunque Docker Desktop suele hacerlo durante la instalaci√≥n si usas una cuenta de administrador).

**Opci√≥n 2: Instalaci√≥n nativa de Docker Engine en WSL.** Tambi√©n puedes instalar Docker directamente en Ubuntu WSL (sin Docker Desktop). Este enfoque puede ser √∫til en entornos de servidor o si prefieres no instalar Docker Desktop. Los pasos generales ser√≠an:

* Instalar los paquetes de Docker Engine en Ubuntu (por ejemplo, usando el repositorio oficial de Docker CE). Esto t√≠picamente involucra instalar `docker-ce`, `docker-ce-cli` y `containerd.io` con apt.
* *Habilitar systemd en WSL:* Docker Engine en Linux normalmente se gestiona con el servicio systemd. WSL 2 ahora soporta systemd (debe habilitarse a√±adiendo en `/etc/wsl.conf` de la distro:

  ```ini
  [boot]
  systemd=true
  ```

  y reiniciando la distro). Una vez con systemd activo, el demonio de Docker podr√° iniciarse autom√°ticamente.
* A√±adir tu usuario al grupo docker, igual que en pasos anteriores, para evitar usar sudo.
* Verificar con `docker run hello-world`.

Este m√©todo requiere m√°s pasos manuales y mantener Docker actualizado por tu cuenta, pero evita tener el componente Desktop en Windows. Para muchos usuarios de WSL, Docker Desktop simplifica las cosas al encargarse del networking, actualizaciones y compatibilidad.

**Uso de Docker en VS Code:** Dado que instalamos la extensi√≥n *Docker* en VS Code, podr√°s manejar tus contenedores e im√°genes desde la interfaz (barra lateral de Docker) al tener Docker funcionando en WSL. Adem√°s, la extensi√≥n *Remote - Containers* (incluida en el pack de Remote Development) te permite abrir entornos de desarrollo dentro de contenedores Docker f√°cilmente (usando archivos `devcontainer.json`), lo cual puede ser √∫til para aislar completamente tu entorno de desarrollo. Todo esto funciona sin problemas gracias a la compatibilidad de Docker con WSL¬†2.

**Tip de rendimiento:** El uso de Docker en WSL 2 es muy eficiente, pero si ejecutas cargas intensivas, considera habilitar la opci√≥n experimental **autoMemoryReclaim** de WSL. Esta caracter√≠stica (disponible desde WSL 1.3.10) permite reclamar memoria no utilizada de la VM de WSL de vuelta a Windows, evitando que, por ejemplo, tras construir im√°genes Docker muy grandes la memoria quede asignada a WSL. Puedes habilitarlo a√±adiendo en tu archivo `.wslconfig` (en Windows, en la ruta `%UserProfile%\.wslconfig`):

```ini
[wsl2]
autoMemoryReclaim=1
```

y reiniciando WSL. Esto ayudar√° a mantener un uso de RAM m√°s estable durante procesos con contenedores.

En resumen, con Docker integrado en WSL podr√°s ejecutar contenedores Linux directamente desde la terminal de Ubuntu, compartir vol√∫menes con el sistema de archivos de Windows y aprovechar la aceleraci√≥n hardware (e.g. GPU, si aplicable) casi como si estuvieras en Linux nativo.

## Flujo de Trabajo Recomendado

Con todas las piezas instaladas, a continuaci√≥n se describen buenas pr√°cticas para organizar el trabajo diario de desarrollo en Data Science/ML, aprovechando las herramientas configuradas:

### Gesti√≥n de entornos y dependencias

Para cada proyecto de data science o machine learning, se recomienda crear un entorno virtual aislado. Utiliza **Poetry o uv** (o en su defecto `venv` manualmente) para inicializar un nuevo proyecto con su propio entorno. Esto garantiza que las dependencias de un proyecto no interfieran con las de otro, y facilita la reproducibilidad. Al empezar un proyecto:

* Inicia un repositorio git nuevo (por ejemplo con `git init` o `gh repo create` si usas GitHub).
* Crea el entorno: si usas Poetry, `poetry init` y `poetry install` crear√°n un venv con un `pyproject.toml` inicial; si usas uv, `uv init` har√° similar. Define all√≠ todas las dependencias requeridas (y marca las de desarrollo, como las herramientas de formateo/lint, en el grupo adecuado).
* Fija versiones para producci√≥n: aseg√∫rate de mantener actualizado el lockfile (e.g. `poetry.lock` o `uv-lock.json`) y versionarlo en git para que otros puedan instalar exactamente las mismas versiones.

En proyectos R, aunque R no tiene entornos virtuales an√°logos a Python, puedes lograr aislamiento usando **{renv}** (un paquete R para gestionar librer√≠as por proyecto) o simplemente documentando la sesi√≥n y usando contenedores Docker/renv para aislar. Si trabajas interactivamente con R en VS Code, las dependencias R instaladas ir√°n a la librer√≠a global de la distro (o a una librer√≠a espec√≠fica de usuario).

### Estructura de proyectos

Adoptar una estructura de ficheros coherente facilita la colaboraci√≥n y la mantenibilidad. Por ejemplo, el patr√≥n de **Cookiecutter Data Science** sugiere:

```
‚îú‚îÄ‚îÄ README.md          <- Descripci√≥n del proyecto, instrucciones.
‚îú‚îÄ‚îÄ data/              <- Datos crudos, subdir para datos procesados, etc.
‚îú‚îÄ‚îÄ notebooks/         <- Notebooks Jupyter (o Quarto) exploratorios.
‚îú‚îÄ‚îÄ src/               <- C√≥digo fuente del proyecto (m√≥dulos, scripts).
‚îú‚îÄ‚îÄ tests/             <- Tests automatizados (si aplican).
‚îú‚îÄ‚îÄ reports/           <- Reportes generados (HTML, PDF, etc. por Quarto).
‚îú‚îÄ‚îÄ pyproject.toml     <- Especificaci√≥n de dependencias (Poetry/uv) para Python.
‚îî‚îÄ‚îÄ ...                <- Otros archivos de config (Dockerfile, .gitignore, etc.)
```

Mant√©n los datos (especialmente los voluminosos) fuera del control de versiones, idealmente en la carpeta `data/` que agregues a `.gitignore`. Los notebooks y reportes generados tampoco deber√≠an versionarse una vez finalizados (en su lugar, conserva el c√≥digo fuente para generarlos). Si usas Quarto, versiona los `.qmd` pero no necesariamente los HTML/PDF resultantes (pueden ser artefactos de release).

### Control de versiones con Git y GitFlow

Usa Git desde el inicio del proyecto. Commits frecuentes y mensajes descriptivos ayudan a rastrear cambios. Es buena idea establecer un flujo de branching profesional; **GitFlow** es una opci√≥n cl√°sica. En GitFlow:

* El repositorio tiene dos ramas principales de larga vida: `main` (o `master`) que contiene las versiones en producci√≥n o liberadas, y `develop` que acumula el trabajo integrando features para la siguiente versi√≥n.
* Para cada nueva funcionalidad o experimento, crea una rama a partir de `develop` (por ejemplo `feature/nueva-analitica`). All√≠ desarrollas aisladamente. Cuando est√© lista, se fusiona de vuelta a `develop` (mediante un Pull Request, idealmente, para revisi√≥n de c√≥digo).
* Peri√≥dicamente, cuando `develop` ha acumulado suficientes cambios estables, se crea una rama `release/x.y.z` para preparar una versi√≥n; al finalizar, se fusiona a `main` (y taguea una versi√≥n) y tambi√©n esos cambios a `develop` si correspondiera.
* Si surge un bug urgente en producci√≥n, se crea una rama desde `main` llamada `hotfix/bug` para corregirlo, y se fusiona de vuelta a `main` y `develop`.

Este modelo mantiene el c√≥digo organizado y facilita colaborar en equipo. No obstante, GitFlow puede ser excesivo para proyectos peque√±os; en esos casos, un flujo m√°s simple (tipo GitHub Flow: ramas cortas desde `main` directamente) podr√≠a bastar. En todo caso, aprovecha las herramientas de Git integradas en VS Code: el panel de control de versiones te permite ver cambios, hacer stage/commit, y las extensiones pueden ejecutarse hooks (como pre-commit) al dar commit para garantizar calidad.

Recuerda agregar un archivo **`.gitignore`** apropiado: incluye `*.env` (credenciales), archivos de configuraci√≥n local, la carpeta de entornos virtuales (si Poetry/uv la crean dentro del proyecto), datos, outputs, etc., para no subirlos al repositorio.

### Pruebas (Testing)

Incluir tests autom√°ticos desde etapas tempranas mejora la confiabilidad del c√≥digo:

* En Python, utiliza **pytest** (u otra framework) para escribir pruebas unitarias para las funciones cr√≠ticas de tu proyecto. Ub√≠calas en la carpeta `tests/` y nomenclatura como `test_*.py`. Puedes ejecutar `pytest` directamente en VS Code (la extensi√≥n de Python detecta tests) o integrarlo con pre-commit (existe un hook para pytest) o en pipelines de CI.
* En R, si est√°s desarrollando un paquete o an√°lisis complejo, considera usar **{testthat}** para estructurar pruebas de unidades. Aunque en trabajos exploratorios de data science no siempre se escriben tests formales, es buena pr√°ctica testear las funciones de transformaci√≥n de datos o c√°lculos importantes.
* Realiza tambi√©n *tests manuales exploratorios*: por ejemplo, verifica que un DataFrame tiene las columnas esperadas tras una operaci√≥n, o que una visualizaci√≥n no tiene valores at√≠picos evidentes. Este tipo de comprobaciones suelen hacerse en notebooks durante la exploraci√≥n, pero puedes convertirlas en aserciones dentro de tus scripts para ejecutarlas rutinariamente.

Incorporar tests en el flujo de desarrollo (por ejemplo, ejecutando `pytest` antes de cada commit o al menos en cada push en un sistema CI) previene que errores regresen inadvertidamente cuando el c√≥digo crece.

### Notebooks y Visualizaci√≥n

Los **notebooks** son fundamentales en data science para la exploraci√≥n y comunicaci√≥n. En este entorno:

* Puedes utilizar Jupyter notebooks (.ipynb) directamente en VS Code: la extensi√≥n de Python proporciona una experiencia interactiva donde puedes ejecutar celdas, ver gr√°ficos inline, etc. Incluso puedes "conectarte" a tu entorno WSL para que los notebooks se ejecuten all√≠.
* Una alternativa potente es usar **Quarto** con notebooks literarios (.qmd), como describimos antes, especialmente para reportes reproducibles que combinen texto y c√≥digo de R/Python.
* Mant√©n los notebooks organizados en la carpeta `notebooks/`, y procura limpiarlos (eliminar resultados o outputs pesados) antes de subirlos a git para evitar diffs ruidosos. Puedes usar pre-commit con hooks como `nbstripout` o `nb-clean` para esto.

En cuanto a **visualizaci√≥n**, aprovecha tanto las bibliotecas de Python (matplotlib, seaborn, plotly, bokeh) como las de R (ggplot2, lattice, etc.) seg√∫n te convenga:

* VS Code mostrar√° las gr√°ficas generadas en notebooks o en scripts interactivos (por ejemplo, si usas la opci√≥n "Run Cell" `#%%` en un script Python, la salida gr√°fica aparece en el **Interactive Window** de VS Code).
* Con R, gracias a `httpgd`, las gr√°ficas aparecen en el panel de Plots de VS Code. Incluso puedes copiarlas o guardarlas desde all√≠.
* Para trabajos colaborativos, considera exportar visualizaciones a formatos est√°ticos (PNG, SVG) o interactivos (HTML) que puedan ser versionados o incluidos en informes.
* Si necesitas dashboards, puedes integrar herramientas como **Plotly Dash**, **Streamlit** o **Shiny** (para R) en tu flujo, ejecut√°ndolos dentro de WSL y accediendo v√≠a localhost en el navegador de Windows.

Por √∫ltimo, adopta la costumbre de documentar tu trabajo: a√±ade descripciones en notebooks, comentarios en el c√≥digo, y quiz√°s utiliza **README.md** o incluso documentos Quarto para explicar resultados. Esto convierte tus hallazgos en reportes comprensibles para otros.

---

Siguiendo esta gu√≠a, un profesional t√©cnico podr√° reproducir un entorno robusto de desarrollo en Windows con WSL2, VS Code, Python y R, combinando lo mejor de ambos ecosistemas. La configuraci√≥n aqu√≠ descrita proporciona aislamiento, reproducibilidad y herramientas de calidad, cubriendo desde la instalaci√≥n hasta el flujo de trabajo diario. ¬°Happy coding! üöÄ

